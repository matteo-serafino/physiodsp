{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PhysioDSP","text":"<p>A comprehensive Python library for processing and analyzing physiological sensor data from wearable devices.</p>"},{"location":"#what-is-physiodsp","title":"What is PhysioDSP?","text":"<p>PhysioDSP is a specialized digital signal processing library designed for physiological monitoring applications. It provides state-of-the-art algorithms for:</p> <ul> <li>Activity Recognition &amp; Quantification: Extract meaningful activity metrics from accelerometer data</li> <li>Cardiac Analysis: Advanced ECG processing and heart rate variability assessment</li> <li>Sensor Data Processing: Robust handling of IMU, ECG, and HRV sensor data</li> <li>Biomarker Extraction: Generate clinically-relevant health metrics from raw sensor signals</li> </ul> <p>Whether you're building a fitness tracker, health monitoring application, or conducting physiological research, PhysioDSP provides the algorithms you need.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#activity-analysis","title":"\ud83c\udfaf Activity Analysis","text":"<ul> <li>ENMO: Euclidean Norm Minus One - standard physical activity metric</li> <li>Zero Crossing: Activity intensity detection</li> <li>Time Above Threshold: Vigorous activity quantification</li> <li>PIM: Multi-axis activity processing</li> </ul>"},{"location":"#cardiac-analysis","title":"\u2764\ufe0f Cardiac Analysis","text":"<ul> <li>ECG Peak Detection: Automatic QRS complex detection and heart rate extraction</li> <li>HRV Score: Comprehensive 0-100 heart rate variability assessment with trend analysis</li> </ul>"},{"location":"#type-safe-design","title":"\ud83d\udd27 Type-Safe Design","text":"<ul> <li>Built with Pydantic for robust data validation</li> <li>Consistent API across all algorithms</li> <li>Type hints for better IDE support</li> </ul>"},{"location":"#configurable","title":"\u2699\ufe0f Configurable","text":"<ul> <li>Customizable algorithm parameters via settings classes</li> <li>Flexible aggregation methods</li> <li>Support for various data formats</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install physiodsp\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>from physiodsp.activity.enmo import ENMO, ENMOSettings\nfrom physiodsp.sensors.imu.accelerometer import AccelerometerData\n\n# Prepare your accelerometer data\naccel_data = AccelerometerData(\n    timestamps=timestamps,\n    x=x_values,\n    y=y_values,\n    z=z_values,\n    fs=64  # 64 Hz sampling frequency\n)\n\n# Run ENMO algorithm\nenmo = ENMO(settings=ENMOSettings(window_len=1, aggregation_window=60))\nresult = enmo.run(accel_data)\n\n# Access results\nprint(result.biomarker)  # Pandas DataFrame\n</code></pre>"},{"location":"#available-algorithms","title":"Available Algorithms","text":""},{"location":"#activity-algorithms","title":"Activity Algorithms","text":"Algorithm Purpose Input Output ENMO Physical activity intensity Accelerometer Activity values Zero Crossing Movement frequency detection Accelerometer Zero crossing counts Time Above Threshold Vigorous activity duration Accelerometer Time above threshold PIM Multi-axis activity IMU (3-axis) Per-axis activity"},{"location":"#cardiac-algorithms","title":"Cardiac Algorithms","text":"Algorithm Purpose Input Output ECG Peak Detection Heart rate extraction ECG signal HR, RR intervals HRV Score Cardiovascular health RMSSD values HRV score (0-100)"},{"location":"#algorithm-design","title":"Algorithm Design","text":"<p>All algorithms in PhysioDSP follow a consistent, intuitive design pattern:</p> <pre><code># 1. Define settings (optional, sensible defaults provided)\nsettings = MyAlgorithmSettings(param1=value1, param2=value2)\n\n# 2. Initialize algorithm\nalgorithm = MyAlgorithm(settings=settings)\n\n# 3. Run on sensor data\nresult = algorithm.run(sensor_data)\n\n# 4. Access results\nprint(result.biomarker)  # Pandas DataFrame with timestamps and values\n</code></pre> <p>All results are returned as Pandas DataFrames for easy integration with data analysis workflows.</p>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#fitness-wellness","title":"\ud83d\udcca Fitness &amp; Wellness","text":"<ul> <li>Daily activity tracking and quantification</li> <li>Exercise intensity monitoring</li> <li>Recovery assessment via HRV</li> </ul>"},{"location":"#clinical-research","title":"\ud83c\udfe5 Clinical Research","text":"<ul> <li>Activity pattern analysis in patient populations</li> <li>Cardiac health monitoring</li> <li>Rehabilitation progress tracking</li> </ul>"},{"location":"#wearable-development","title":"\ud83d\udd2c Wearable Development","text":"<ul> <li>Activity-based user feedback</li> <li>Sleep detection and analysis</li> <li>Real-time health monitoring</li> </ul>"},{"location":"#mobile-applications","title":"\ud83d\udcf1 Mobile Applications","text":"<ul> <li>Personalized health dashboards</li> <li>Trend analysis and insights</li> <li>User engagement metrics</li> </ul>"},{"location":"#data-types-supported","title":"Data Types Supported","text":"<ul> <li>Accelerometer: 3-axis acceleration data (typically 20-100 Hz)</li> <li>Gyroscope: 3-axis rotation rate (optional, for advanced analysis)</li> <li>Magnetometer: 3-axis magnetic field (optional, for orientation)</li> <li>ECG: Single-channel electrocardiogram (typically 250+ Hz)</li> <li>HRV: Aggregated RMSSD values</li> </ul>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Home (this page): Overview and quick start</li> <li>About: Project information and vision</li> <li>Algorithms: Detailed documentation for each algorithm</li> <li>Algorithm description and mathematics</li> <li>Parameter explanations</li> <li>Usage examples</li> <li>Clinical applications</li> <li>Performance considerations</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.11</li> <li>NumPy &gt;= 2.4.0</li> <li>Pandas &gt;= 2.3.3</li> <li>SciPy &gt;= 1.16.3</li> <li>Pydantic &gt;= 2.12.0</li> </ul>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>Check the algorithm-specific documentation for detailed examples</li> <li>Review the parameter descriptions in each algorithm's settings class</li> <li>Examine the examples in the <code>tests/</code> directory for real-world usage patterns</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! If you'd like to: - Add new algorithms - Improve existing implementations - Report bugs - Suggest enhancements</p> <p>Please check the project repository for contribution guidelines.</p>"},{"location":"#license","title":"License","text":"<p>[License information to be added]</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>This library draws inspiration from established signal processing techniques and physiological monitoring best practices in research and clinical settings.</p> <p>Ready to get started? Pick an algorithm from the Algorithms section and follow the usage examples, or jump to the About page to learn more about the project.</p>"},{"location":"about/","title":"About","text":""},{"location":"algorithms/activity_score/","title":"Activity Score Algorithm","text":""},{"location":"algorithms/activity_score/#overview","title":"Overview","text":"<p>The Activity Score Algorithm provides a personalized 0-100 daily activity and recovery score based on steps, sleep, training, and resting metrics. It uses individual baseline data to personalize scoring, accounting for natural variations in activity levels and sleep patterns across different users.</p> <p>Algorithm Name: ActivityScore Version: v0.1.0</p>"},{"location":"algorithms/activity_score/#algorithm-description","title":"Algorithm Description","text":"<p>The Activity Score is calculated using a multi-factor personalization approach:</p>"},{"location":"algorithms/activity_score/#step-1-baseline-statistics-calculation","title":"Step 1: Baseline Statistics Calculation","text":"<p>Using historical data (default: 30 days prior to current day): - Steps: Median, standard deviation, 25th and 75th percentiles - Sleep Hours: Median, standard deviation, 25th and 75th percentiles - Training Minutes: Median, standard deviation, 25th and 75th percentiles - Resting Minutes: Median, standard deviation, 25th and 75th percentiles</p>"},{"location":"algorithms/activity_score/#step-2-individual-metric-scoring","title":"Step 2: Individual Metric Scoring","text":"<p>Each metric is scored 0-100 based on baseline-relative thresholds:</p>"},{"location":"algorithms/activity_score/#steps-scoring","title":"Steps Scoring","text":"<ul> <li>Excellent (\u226595): Steps \u2265 75th percentile + 1 std</li> <li>Very Good (\u226585): Steps \u2265 75th percentile</li> <li>Good (\u226570): Steps \u2265 median</li> <li>Fair (\u226550): Steps \u2265 25th percentile</li> <li>Poor: Steps &lt; 25th percentile</li> </ul>"},{"location":"algorithms/activity_score/#sleep-hours-scoring","title":"Sleep Hours Scoring","text":"<ul> <li>Excellent (\u226595): Sleep \u2265 75th percentile + 0.5 std</li> <li>Very Good (\u226585): Sleep \u2265 75th percentile</li> <li>Good (\u226570): Sleep \u2265 median</li> <li>Fair (\u226550): Sleep \u2265 25th percentile - 0.5 std</li> <li>Poor: Sleep &lt; 25th percentile - 0.5 std</li> </ul>"},{"location":"algorithms/activity_score/#training-minutes-scoring","title":"Training Minutes Scoring","text":"<ul> <li>Excellent (\u226595): Training \u2265 75th percentile + 1 std</li> <li>Very Good (\u226585): Training \u2265 75th percentile</li> <li>Good (\u226570): Training \u2265 median</li> <li>Fair (\u226550): Training \u2265 25th percentile</li> <li>Poor: Training &lt; 25th percentile</li> </ul>"},{"location":"algorithms/activity_score/#resting-minutes-scoring","title":"Resting Minutes Scoring","text":"<ul> <li>Excellent (\u226595): Resting \u2265 75th percentile</li> <li>Very Good (\u226585): Resting \u2265 median</li> <li>Good (\u226570): Resting \u2265 25th percentile</li> <li>Fair (\u226550): Resting \u2265 10th percentile</li> <li>Poor: Resting &lt; 10th percentile</li> </ul>"},{"location":"algorithms/activity_score/#step-3-weighted-combination","title":"Step 3: Weighted Combination","text":"<p>$$ActivityScore = (steps_score \u00d7 0.25) + (sleep_score \u00d7 0.35) + (training_score \u00d7 0.25) + (resting_score \u00d7 0.15)$$</p> <p>Final score is clamped to 0-100 range.</p>"},{"location":"algorithms/activity_score/#parameters","title":"Parameters","text":""},{"location":"algorithms/activity_score/#activityscoresettings","title":"ActivityScoreSettings","text":"<ul> <li>baseline_window_days (default: 30) - Number of prior days used for baseline calculation</li> <li>step_weight (default: 0.25) - Weight for steps component</li> <li>sleep_weight (default: 0.35) - Weight for sleep component</li> <li>training_weight (default: 0.25) - Weight for training component</li> <li>resting_weight (default: 0.15) - Weight for resting component</li> </ul>"},{"location":"algorithms/activity_score/#usage-example","title":"Usage Example","text":"<pre><code>from physiodsp.activity.activity_score import ActivityScore, ActivityScoreSettings\nfrom pandas import DataFrame\nfrom datetime import datetime, timedelta\n\n# Create 31 days of activity data (30-day baseline + 1 current day)\ndates = [datetime.now() - timedelta(days=x) for x in range(30, -1, -1)]\ndata = DataFrame({\n    'date': dates,\n    'steps': [8500] * 31,\n    'sleep_hours': [7.5] * 31,\n    'training_minutes': [45] * 31,\n    'resting_minutes': [500] * 31\n})\n\n# Initialize Activity Score with default settings\nsettings = ActivityScoreSettings(baseline_window_days=30)\nalgorithm = ActivityScore(settings=settings)\n\n# Run algorithm\nresult = algorithm.run(data)\n\n# Get activity score and component scores\nprint(result.biomarker_agg)\n# Output:\n# activity_score: 72\n# step_score: 70\n# sleep_score: 75\n# training_score: 68\n# resting_score: 70\n# baseline_days_used: 30\n</code></pre>"},{"location":"algorithms/activity_score/#output","title":"Output","text":"<p>The algorithm returns a result object with:</p>"},{"location":"algorithms/activity_score/#biomarker_agg-dataframe","title":"biomarker_agg (DataFrame)","text":"<ul> <li>activity_score: Overall activity score (0-100)</li> <li>step_score: Steps component score (0-100)</li> <li>sleep_score: Sleep component score (0-100)</li> <li>training_score: Training component score (0-100)</li> <li>resting_score: Resting component score (0-100)</li> <li>baseline_days_used: Number of baseline days used for calculation</li> </ul>"},{"location":"algorithms/activity_score/#baseline_stats-dict","title":"baseline_stats (Dict)","text":"<ul> <li>steps_median, steps_std, steps_p25, steps_p75</li> <li>sleep_median, sleep_std, sleep_p25, sleep_p75</li> <li>training_median, training_std, training_p25, training_p75</li> <li>resting_median, resting_std, resting_p25, resting_p75</li> </ul>"},{"location":"algorithms/activity_score/#score-interpretation","title":"Score Interpretation","text":"Score Range Interpretation Recommendation \u226585 Excellent - Outstanding activity and recovery balance Maintain current routine 70-84 Good - Healthy activity levels with adequate recovery Continue current habits 50-69 Fair - Room for improvement in activity or recovery Increase activity or improve sleep 30-49 Poor - Significant imbalance in activity or recovery Action needed for health &lt;30 Critical - Urgent attention needed to activity and recovery Consult healthcare provider"},{"location":"algorithms/activity_score/#key-features","title":"Key Features","text":""},{"location":"algorithms/activity_score/#personalized-baseline","title":"Personalized Baseline","text":"<p>Uses individual baseline rather than population averages, accounting for: - Natural variations in activity levels - Age and fitness level differences - Individual sleep needs - Work and lifestyle schedules</p>"},{"location":"algorithms/activity_score/#balanced-weighting","title":"Balanced Weighting","text":"<ul> <li>Sleep (35%): Highest weight, reflecting critical importance for recovery</li> <li>Steps (25%) + Training (25%): Equal activity components</li> <li>Resting (15%): Recovery quality metrics</li> </ul>"},{"location":"algorithms/activity_score/#multi-component-analysis","title":"Multi-Component Analysis","text":"<p>Evaluates four independent dimensions: - Steps: Daily physical activity volume - Sleep: Nighttime recovery quality - Training: Structured exercise intensity - Resting: Daytime recovery and low-activity periods</p>"},{"location":"algorithms/activity_score/#trend-aware","title":"Trend-Aware","text":"<p>Automatically adapts to individual patterns by using rolling baseline calculation.</p>"},{"location":"algorithms/activity_score/#practical-applications","title":"Practical Applications","text":"<ul> <li>Fitness Tracking: Monitor daily activity and recovery balance</li> <li>Athlete Monitoring: Track training load and recovery</li> <li>Health Management: Identify patterns affecting wellbeing</li> <li>Behavior Change: Personalized feedback on activity goals</li> <li>Occupational Health: Monitor activity levels in sedentary jobs</li> <li>Sleep Optimization: Balance activity with adequate rest</li> </ul>"},{"location":"algorithms/activity_score/#factors-affecting-score","title":"Factors Affecting Score","text":""},{"location":"algorithms/activity_score/#positive-factors","title":"Positive Factors","text":"<ul> <li>Consistent physical activity (8,000-12,000+ steps/day)</li> <li>Adequate sleep (7-8.5 hours/night)</li> <li>Regular structured training</li> <li>Sufficient rest and recovery time</li> </ul>"},{"location":"algorithms/activity_score/#negative-factors","title":"Negative Factors","text":"<ul> <li>Sedentary behavior (&lt;5,000 steps/day)</li> <li>Sleep deprivation (&lt;6 hours/night)</li> <li>Overtraining without recovery</li> <li>Excessive resting or low activity</li> </ul>"},{"location":"algorithms/activity_score/#minimum-data-requirements","title":"Minimum Data Requirements","text":"<ul> <li>Minimum: At least 2 days of data (1 baseline day + 1 evaluation day)</li> <li>Recommended: At least 30 days for stable baseline</li> <li>Optimal: 60-90 days for seasonal pattern detection</li> </ul>"},{"location":"algorithms/activity_score/#limitations","title":"Limitations","text":"<ul> <li>Requires consistent daily data logging</li> <li>Does not account for activity intensity beyond training minutes</li> <li>Not suitable for irregular schedules (shift workers without adjustment)</li> <li>Sleep quality not measured (duration only)</li> <li>Does not detect non-wear periods or data gaps automatically</li> <li>Baseline calculation requires sufficient historical data</li> </ul>"},{"location":"algorithms/activity_score/#algorithm-parameters-customization","title":"Algorithm Parameters Customization","text":"<pre><code># Custom weighting emphasizing sleep\ncustom_settings = ActivityScoreSettings(\n    baseline_window_days=30,\n    step_weight=0.20,\n    sleep_weight=0.45,\n    training_weight=0.20,\n    resting_weight=0.15\n)\nalgorithm = ActivityScore(settings=custom_settings)\n\n# Short-term baseline (last 15 days)\nshort_baseline = ActivityScoreSettings(baseline_window_days=15)\nalgorithm = ActivityScore(settings=short_baseline)\n</code></pre>"},{"location":"algorithms/activity_score/#related-metrics","title":"Related Metrics","text":"<p>Complementary Metrics: - ENMO (Euclidean Norm Minus One): Raw accelerometer-based activity metric - HRV Score: Heart rate variability for autonomic nervous system assessment - ECG Analysis: Heart rate and cardiac metrics</p>"},{"location":"algorithms/activity_score/#references","title":"References","text":"<ul> <li>Wearable activity data standards and metrics</li> <li>Sleep hygiene research and recommendations</li> <li>Training load and recovery models in sports science</li> <li>Personalized health monitoring approaches</li> </ul>"},{"location":"algorithms/activity_score/#version-history","title":"Version History","text":"<ul> <li>v0.1.0 (2026-02-21): Initial alpha release with 30-day baseline personalization</li> </ul>"},{"location":"algorithms/ecg_peak_detection/","title":"ECG Peak Detector Algorithm","text":""},{"location":"algorithms/ecg_peak_detection/#overview","title":"Overview","text":"<p>The ECG Peak Detector is a QRS complex detection algorithm that identifies R-peaks in electrocardiogram signals. It automatically extracts heart rate and inter-beat intervals from raw ECG data.</p> <p>Algorithm Name: EcgPeakDetector Version: v0.1.0</p>"},{"location":"algorithms/ecg_peak_detection/#algorithm-description","title":"Algorithm Description","text":"<p>This algorithm implements a Pan-Tompkins-like approach for robust QRS detection:</p> <ol> <li>Band-pass Filtering: Filters ECG signal between 5-15 Hz to enhance QRS complexes</li> <li>Derivative Filtering: Applies a 5-tap derivative filter to amplify signal changes</li> <li>Signal Squaring: Squares the derivative output to emphasize peaks</li> <li>Moving Average: Applies moving average filter (window: 0.15 seconds) for smoothing</li> <li>Peak Detection: Identifies peaks using adaptive thresholding</li> <li>RR Interval Calculation: Computes inter-beat intervals and heart rate</li> </ol>"},{"location":"algorithms/ecg_peak_detection/#parameters","title":"Parameters","text":"<ul> <li>FILTER_ORDER: 3 (Butterworth filter order)</li> <li>LOWER_F_CUT: 5 Hz (lower cutoff frequency)</li> <li>UPPER_F_CUT: 15 Hz (upper cutoff frequency)</li> <li>WIN_LEN_SEC: 0.150 seconds (moving average window)</li> </ul>"},{"location":"algorithms/ecg_peak_detection/#usage-example","title":"Usage Example","text":"<pre><code>from physiodsp.ecg.peak_detector import EcgPeakDetector\nfrom physiodsp.sensors.ecg import EcgData\nimport numpy as np\n\n# Create sample ECG data (250 Hz sampling rate)\ntimestamps = np.arange(0, 60, 1/250)  # 60 seconds at 250 Hz\n# Simulate ECG signal with 60 bpm heart rate\nheart_rate = 60\nt = timestamps\necg_signal = (\n    0.5 * np.sin(2 * np.pi * (heart_rate/60) * t) +\n    0.2 * np.sin(2 * np.pi * (2*heart_rate/60) * t) +\n    0.1 * np.sin(2 * np.pi * (3*heart_rate/60) * t)\n)\n\necg_data = EcgData(\n    timestamps=timestamps,\n    values=ecg_signal,\n    fs=250  # 250 Hz sampling frequency\n)\n\n# Initialize peak detector\ndetector = EcgPeakDetector()\n\n# Run algorithm\nresult = detector.run(ecg_data)\n\n# Get results\nprint(result.biomarker)\n# DataFrame columns:\n# - timestamps: Detected R-peak timestamps\n# - inter_beat_interval: RR intervals in milliseconds\n# - heart_rate: Instantaneous heart rate in bpm\n</code></pre>"},{"location":"algorithms/ecg_peak_detection/#output","title":"Output","text":"<p>The algorithm returns a Pandas DataFrame with:</p> <ul> <li>timestamps: Time points of detected R-peaks</li> <li>inter_beat_interval: RR intervals in milliseconds</li> <li>heart_rate: Instantaneous heart rate in beats per minute (bpm)</li> </ul>"},{"location":"algorithms/ecg_peak_detection/#signal-processing-steps-explained","title":"Signal Processing Steps Explained","text":""},{"location":"algorithms/ecg_peak_detection/#1-band-pass-filtering","title":"1. Band-pass Filtering","text":"<p>Removes baseline wander (&lt;5 Hz) and noise (&gt;15 Hz), preserving QRS characteristics.</p>"},{"location":"algorithms/ecg_peak_detection/#2-derivative-filtering","title":"2. Derivative Filtering","text":"<p>Enhances the steep slopes of QRS complexes: $$h[n] = [-1/8, -2/8, 0, 2/8, 1/8]$$</p>"},{"location":"algorithms/ecg_peak_detection/#3-squaring","title":"3. Squaring","text":"<p>Nonlinear operation to emphasize peaks: $y[n] = (x[n])^2$</p>"},{"location":"algorithms/ecg_peak_detection/#4-moving-average","title":"4. Moving Average","text":"<p>Smoothing filter with window of 0.15 seconds at sampling rate.</p>"},{"location":"algorithms/ecg_peak_detection/#5-peak-detection","title":"5. Peak Detection","text":"<p>Adaptive threshold based on mean signal level, with minimum distance constraint to avoid detecting multiple peaks within same QRS.</p>"},{"location":"algorithms/ecg_peak_detection/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Continuous heart rate monitoring</li> <li>Arrhythmia detection</li> <li>Exercise intensity assessment</li> <li>Sleep quality monitoring</li> <li>ECG signal quality validation</li> </ul>"},{"location":"algorithms/ecg_peak_detection/#important-notes","title":"Important Notes","text":"<ul> <li>Optimal for ECG signals sampled at 250 Hz or higher</li> <li>Assumes relatively clean ECG signals</li> <li>May struggle with severe noise or motion artifacts</li> <li>Best used with proper electrode placement</li> </ul>"},{"location":"algorithms/ecg_peak_detection/#limitations","title":"Limitations","text":"<ul> <li>Sensitive to baseline wander if pre-filtering is inadequate</li> <li>May miss peaks during high-frequency noise</li> <li>Assumes relatively regular heart rhythms for optimal performance</li> <li>Requires adequate ECG signal quality</li> </ul>"},{"location":"algorithms/ecg_peak_detection/#references","title":"References","text":"<ul> <li>Pan, J., &amp; Tompkins, W. J. (1985). A real-time QRS detection algorithm. IEEE transactions on biomedical engineering, (3), 230-236.</li> <li>Accelerometer-based QRS detection variations</li> </ul>"},{"location":"algorithms/enmo/","title":"ENMO (Euclidean Norm Minus One)","text":""},{"location":"algorithms/enmo/#overview","title":"Overview","text":"<p>ENMO is a physical activity metric derived from accelerometer data. It represents the Euclidean norm of the acceleration vector minus 1g (gravitational acceleration), with negative values clipped to zero.</p> <p>Algorithm Name: ENMO Version: v0.1.0</p>"},{"location":"algorithms/enmo/#algorithm-description","title":"Algorithm Description","text":"<p>ENMO is commonly used in wearable sensor research to quantify physical activity intensity. The calculation involves:</p> <ol> <li>Computing the magnitude of the 3D acceleration vector: $\\sqrt{x^2 + y^2 + z^2}$</li> <li>Subtracting 1g (gravitational component): $ENMO = magnitude - 1$</li> <li>Clipping negative values to 0: $ENMO = \\max(0, magnitude - 1)$</li> <li>Aggregating over specified time windows</li> </ol>"},{"location":"algorithms/enmo/#parameters","title":"Parameters","text":""},{"location":"algorithms/enmo/#enmosettings","title":"ENMOSettings","text":"<ul> <li>window_len (default: 1 second) - Processing window length for calculating rolling statistics</li> <li>aggregation_window (default: 60 seconds) - Time window for data aggregation</li> </ul>"},{"location":"algorithms/enmo/#usage-example","title":"Usage Example","text":"<pre><code>from physiodsp.activity.enmo import ENMO, ENMOSettings\nfrom physiodsp.sensors.imu.accelerometer import AccelerometerData\nimport numpy as np\n\n# Create sample accelerometer data\ntimestamps = np.arange(0, 100, 0.01)  # 100 seconds at 100 Hz\nx = np.random.normal(0, 0.1, len(timestamps))\ny = np.random.normal(0, 0.1, len(timestamps))\nz = np.ones(len(timestamps)) + np.random.normal(0, 0.1, len(timestamps))\n\naccel_data = AccelerometerData(\n    timestamps=timestamps,\n    x=x,\n    y=y,\n    z=z,\n    fs=100  # 100 Hz sampling frequency\n)\n\n# Initialize ENMO with custom settings\nsettings = ENMOSettings(window_len=2, aggregation_window=120)\nenmo = ENMO(settings=settings)\n\n# Run algorithm\nresult = enmo.run(accel_data)\n\n# Get results\nprint(result.biomarker)  # DataFrame with timestamps and ENMO values\n\n# Aggregate results\nresult.aggregate(method='mean')\nprint(result.biomarker_agg)\n</code></pre>"},{"location":"algorithms/enmo/#output","title":"Output","text":"<p>The algorithm returns a Pandas DataFrame with:</p> <ul> <li>timestamps: Unix timestamps of window centers</li> <li>values: Mean ENMO values for each window</li> </ul>"},{"location":"algorithms/enmo/#clinicalresearch-applications","title":"Clinical/Research Applications","text":"<ul> <li>Quantifying daily physical activity levels</li> <li>Distinguishing sedentary vs. active periods</li> <li>Monitoring activity patterns in health studies</li> <li>Wearable device activity tracking</li> </ul>"},{"location":"algorithms/enmo/#references","title":"References","text":"<ul> <li>Accelerometer-based activity monitoring</li> <li>Physical activity quantification from wearable sensors</li> </ul>"},{"location":"algorithms/hrv_score/","title":"HRV Score Algorithm","text":""},{"location":"algorithms/hrv_score/#overview","title":"Overview","text":"<p>The HRV Score Algorithm computes a normalized 0-100 Heart Rate Variability score based on RMSSD (Root Mean Square of Successive Differences) values. It incorporates trend analysis and stability metrics to provide a comprehensive HRV assessment.</p> <p>Algorithm Name: HrvScoreAlgorithm Version: v0.1.0</p>"},{"location":"algorithms/hrv_score/#algorithm-description","title":"Algorithm Description","text":"<p>The HRV Score is calculated using a multi-factor approach:</p>"},{"location":"algorithms/hrv_score/#step-1-baseline-and-variability-calculation","title":"Step 1: Baseline and Variability Calculation","text":"<ul> <li>Baseline: Median RMSSD from the baseline period (default: 30 days)</li> <li>Standard Deviation: Variability measure of baseline RMSSD</li> <li>Coefficient of Variation: $CV = \\frac{std}{baseline}$</li> </ul>"},{"location":"algorithms/hrv_score/#step-2-z-score-computation","title":"Step 2: Z-Score Computation","text":"<p>$$Z = \\frac{current_rmssd - baseline}{std}$$</p>"},{"location":"algorithms/hrv_score/#step-3-base-score-mapping","title":"Step 3: Base Score Mapping","text":"<p>Two methods available (default: sigmoid): - Sigmoid Method: $score = 50 + 30 \\times \\tanh(0.5 \\times Z)$ - Percentile Method: Maps current value to percentile of baseline distribution</p>"},{"location":"algorithms/hrv_score/#step-4-trend-bonus","title":"Step 4: Trend Bonus","text":"<p>Compares first 10 days vs. last 10 days of baseline: - Trend &gt; 10%: +10 points (improving) - Trend &gt; 5%: +5 points - Trend &lt; -5%: -5 points (declining) - Otherwise: 0 points</p>"},{"location":"algorithms/hrv_score/#step-5-stability-penalty","title":"Step 5: Stability Penalty","text":"<p>Based on coefficient of variation: - CV &gt; 15%: -10 points (high variability) - CV &gt; 10%: -5 points (moderate variability) - Otherwise: 0 points</p>"},{"location":"algorithms/hrv_score/#final-score","title":"Final Score","text":"<p>$$HRV_Score = \\min(100, \\max(0, base_score + trend_bonus + stability_penalty))$$</p>"},{"location":"algorithms/hrv_score/#parameters","title":"Parameters","text":""},{"location":"algorithms/hrv_score/#hrvscoresettings","title":"HrvScoreSettings","text":"<ul> <li>window_len (default: 30 days) - Baseline period for comparison</li> <li>method (default: \"sigmoid\") - Scoring method: \"sigmoid\" or \"percentile\"</li> </ul>"},{"location":"algorithms/hrv_score/#usage-example","title":"Usage Example","text":"<pre><code>from physiodsp.hrv.hrv_score import HrvScore, HrvScoreSettings\nfrom physiodsp.sensors.hrv import HrvData\nimport numpy as np\n\n# Create sample HRV data (30+ days of daily RMSSD values)\ntimestamps = np.arange(0, 31)  # 31 days\nrmssd_values = np.random.normal(50, 10, 31)  # RMSSD in milliseconds\n\nhrv_data = HrvData(\n    timestamps=timestamps,\n    values=rmssd_values\n)\n\n# Initialize HRV Score with default settings\nsettings = HrvScoreSettings(window_len=30, method=\"sigmoid\")\nhrv = HrvScore(settings=settings)\n\n# Run algorithm\nresult = hrv.run(hrv_data)\n\n# Get HRV score (0-100)\nprint(result.biomarker_agg)\n# Output:\n# timestamps: 30 (current day)\n# hrv_score: 65 (example score)\n</code></pre>"},{"location":"algorithms/hrv_score/#output","title":"Output","text":"<p>The algorithm returns a Pandas DataFrame with:</p> <ul> <li>timestamps: Current timestamp</li> <li>hrv_score: HRV score in 0-100 range</li> </ul>"},{"location":"algorithms/hrv_score/#score-interpretation","title":"Score Interpretation","text":"Score Range Interpretation Status 80-100 Excellent cardiovascular fitness Very Good 60-79 Good HRV, balanced nervous system Good 40-59 Moderate HRV Normal 20-39 Low HRV, elevated stress Concerning 0-19 Very low HRV, high stress Poor"},{"location":"algorithms/hrv_score/#key-features","title":"Key Features","text":""},{"location":"algorithms/hrv_score/#trend-analysis","title":"Trend Analysis","text":"<p>Identifies if HRV is improving or declining over time, providing actionable insights for lifestyle interventions.</p>"},{"location":"algorithms/hrv_score/#stability-penalty","title":"Stability Penalty","text":"<p>High variability in HRV measurements (indicating inconsistent data or lifestyle) reduces the score, encouraging more consistent measurement practices.</p>"},{"location":"algorithms/hrv_score/#baseline-normalization","title":"Baseline Normalization","text":"<p>Uses individual baseline rather than population averages, accounting for natural individual differences in HRV.</p>"},{"location":"algorithms/hrv_score/#flexible-scoring-methods","title":"Flexible Scoring Methods","text":"<p>Sigmoid Method: Smooth mapping that handles outliers well - Centered at 50 for baseline median - Responsive to deviations from baseline</p> <p>Percentile Method: Direct comparison to baseline distribution - More robust to outliers - Intuitive percentile interpretation</p>"},{"location":"algorithms/hrv_score/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Autonomic nervous system assessment</li> <li>Recovery and readiness monitoring</li> <li>Stress level evaluation</li> <li>Cardiovascular health tracking</li> <li>Training adaptation monitoring</li> </ul>"},{"location":"algorithms/hrv_score/#hrv-background","title":"HRV Background","text":"<p>HRV (Heart Rate Variability) represents the variation in time intervals between consecutive heartbeats. Higher HRV generally indicates: - Better cardiovascular fitness - Better stress management - Better recovery - Lower all-cause mortality risk</p>"},{"location":"algorithms/hrv_score/#factors-affecting-hrv","title":"Factors Affecting HRV","text":"<ul> <li>Positive Factors: Exercise, sleep, stress management, meditation</li> <li>Negative Factors: Sleep deprivation, stress, illness, overtraining, poor diet</li> </ul>"},{"location":"algorithms/hrv_score/#limitations","title":"Limitations","text":"<ul> <li>Requires at least baseline window length of data</li> <li>RMSSD should be measured consistently (time of day, position, etc.)</li> <li>Environmental and lifestyle factors significantly impact scores</li> <li>Not suitable for atrial fibrillation or irregular rhythms</li> </ul>"},{"location":"algorithms/hrv_score/#references","title":"References","text":"<ul> <li>Shaffer, F., &amp; Ginsberg, J. P. (2017). An overview of heart rate variability metrics and norms. Frontiers in public health, 5, 258.</li> <li>Task Force of the European Society of Cardiology and the North American Society of Pacing and Electrophysiology. (1996). Heart rate variability: standards of measurement, physiological interpretation and clinical use. Circulation, 93(5), 1043-1065.</li> </ul>"},{"location":"algorithms/pim/","title":"PIM (Proportional Integration Mode) Algorithm","text":""},{"location":"algorithms/pim/#overview","title":"Overview","text":"<p>The PIM (Proportional Integration Mode) Algorithm processes 3-axis IMU (Inertial Measurement Unit) data to extract activity metrics. It computes the absolute values of acceleration on each axis and aggregates them over time windows.</p> <p>Algorithm Name: PIMAlgorithm Version: v0.1.0</p>"},{"location":"algorithms/pim/#algorithm-description","title":"Algorithm Description","text":"<p>PIM is a signal processing technique that:</p> <ol> <li>Computes absolute acceleration values for X, Y, and Z axes</li> <li>Aggregates data over time windows using the specified method</li> <li>Provides multi-axis activity representation</li> </ol> <p>This approach preserves directional information while quantifying movement intensity across all three spatial dimensions.</p>"},{"location":"algorithms/pim/#parameters","title":"Parameters","text":"<ul> <li>Aggregation Window: Default 5 seconds</li> <li>Aggregation Method: Sum (default) or other statistical measures (mean, max, etc.)</li> </ul>"},{"location":"algorithms/pim/#usage-example","title":"Usage Example","text":"<pre><code>from physiodsp.activity.pim import PIMAlgorithm\nfrom physiodsp.sensors.imu.base import IMUData\nimport numpy as np\n\n# Create sample IMU data\ntimestamps = np.arange(0, 100, 0.01)  # 100 seconds at 100 Hz\nx = np.random.normal(0, 0.2, len(timestamps))\ny = np.random.normal(0, 0.2, len(timestamps))\nz = np.ones(len(timestamps)) + np.random.normal(0, 0.2, len(timestamps))\n\nimu_data = IMUData(\n    timestamps=timestamps,\n    x=x,\n    y=y,\n    z=z,\n    fs=100  # 100 Hz sampling frequency\n)\n\n# Initialize PIM algorithm\npim = PIMAlgorithm()\n\n# Estimate activity\nresult = pim.estimate(imu_data)\n\n# Aggregate results\nresult.aggregate(method='sum')\n\n# Get aggregated results\nprint(result.biomarker_agg)\n</code></pre>"},{"location":"algorithms/pim/#output","title":"Output","text":"<p>The algorithm returns a Pandas DataFrame with:</p> <ul> <li>timestamps_unix: Aggregated time windows (unix timestamps)</li> <li>x: Aggregated absolute acceleration on X-axis</li> <li>y: Aggregated absolute acceleration on Y-axis</li> <li>z: Aggregated absolute acceleration on Z-axis</li> </ul>"},{"location":"algorithms/pim/#applications","title":"Applications","text":"<ul> <li>Multi-axis activity monitoring</li> <li>Movement magnitude assessment</li> <li>Directional activity analysis</li> <li>Device orientation-independent activity tracking</li> </ul>"},{"location":"algorithms/pim/#advantages","title":"Advantages","text":"<ul> <li>Preserves directional information</li> <li>Resistant to device orientation changes</li> <li>Suitable for complex movement patterns</li> <li>Useful for rehabilitation and sports analytics</li> </ul>"},{"location":"algorithms/pim/#references","title":"References","text":"<ul> <li>Proportional Integration algorithms in signal processing</li> <li>Multi-axis accelerometer data analysis</li> </ul>"},{"location":"algorithms/time_above_threshold/","title":"Time Above Threshold Algorithm","text":""},{"location":"algorithms/time_above_threshold/#overview","title":"Overview","text":"<p>The Time Above Threshold algorithm measures the duration and frequency of periods when acceleration exceeds a specified threshold. This metric is useful for identifying active periods and activity intensity levels from accelerometer data.</p> <p>Algorithm Name: TimeAboveThrAlgorithm Version: v0.1.0</p>"},{"location":"algorithms/time_above_threshold/#algorithm-description","title":"Algorithm Description","text":"<p>This algorithm detects periods of elevated acceleration that exceed a user-defined threshold. It:</p> <ol> <li>Computes absolute acceleration values for each axis</li> <li>Identifies samples exceeding the threshold</li> <li>Calculates time spent above threshold within windows</li> <li>Aggregates results over specified time periods</li> </ol> <p>Time above threshold can indicate intensity of physical activity, with higher values suggesting more intense or vigorous activity.</p>"},{"location":"algorithms/time_above_threshold/#parameters","title":"Parameters","text":""},{"location":"algorithms/time_above_threshold/#timeabovethrsettings","title":"TimeAboveThrSettings","text":"<ul> <li>window_len (default: 1 second) - Processing window length for calculating time above threshold</li> <li>aggregation_window (default: 60 seconds) - Time window for data aggregation</li> <li>threshold (default: 0.1 g) - Acceleration threshold in gravitational units (g)</li> </ul>"},{"location":"algorithms/time_above_threshold/#usage-example","title":"Usage Example","text":"<pre><code>from physiodsp.activity.time_above_thr import TimeAboveThr, TimeAboveThrSettings\nfrom physiodsp.sensors.imu.base import IMUData\nimport numpy as np\n\n# Create sample IMU data\ntimestamps = np.arange(0, 100, 0.01)  # 100 seconds at 100 Hz\nx = np.random.uniform(-0.5, 0.5, len(timestamps))\ny = np.random.uniform(-0.5, 0.5, len(timestamps))\nz = np.ones(len(timestamps))\n\nimu_data = IMUData(\n    timestamps=timestamps,\n    x=x,\n    y=y,\n    z=z,\n    fs=100  # 100 Hz sampling frequency\n)\n\n# Initialize Time Above Threshold with custom settings\nsettings = TimeAboveThrSettings(\n    window_len=1,\n    aggregation_window=60,\n    threshold=0.2  # 0.2g threshold\n)\ntat = TimeAboveThr(settings=settings)\n\n# Run algorithm\nresult = tat.run(imu_data)\n\n# Get results\nprint(result.biomarker)  # DataFrame with time above threshold values\n</code></pre>"},{"location":"algorithms/time_above_threshold/#output","title":"Output","text":"<p>The algorithm returns a Pandas DataFrame with:</p> <ul> <li>timestamps: Unix timestamps of window centers</li> <li>x: Time (or count) of X-axis samples above threshold</li> <li>y: Time (or count) of Y-axis samples above threshold</li> <li>z: Time (or count) of Z-axis samples above threshold</li> </ul>"},{"location":"algorithms/time_above_threshold/#applications","title":"Applications","text":"<ul> <li>Vigorous activity detection</li> <li>Activity intensity classification</li> <li>Movement pattern monitoring</li> <li>Rehabilitation progress tracking</li> <li>Physical therapy compliance</li> </ul>"},{"location":"algorithms/time_above_threshold/#clinical-significance","title":"Clinical Significance","text":"<p>Different thresholds can identify different activity intensities: - Lower thresholds (0.05-0.1g): Light activity - Medium thresholds (0.2-0.5g): Moderate activity - Higher thresholds (&gt;0.5g): Vigorous activity</p>"},{"location":"algorithms/time_above_threshold/#references","title":"References","text":"<ul> <li>Accelerometer-based activity intensity measurement</li> <li>Threshold-based activity recognition</li> </ul>"},{"location":"algorithms/zero_crossing/","title":"Zero Crossing Algorithm","text":""},{"location":"algorithms/zero_crossing/#overview","title":"Overview","text":"<p>The Zero Crossing algorithm detects activity by counting the number of times the acceleration signal crosses zero within a specified threshold. This metric is useful for identifying movement patterns and activity intensity from accelerometer data.</p> <p>Algorithm Name: ZeroCrossingAlgorithm Version: v0.1.0</p>"},{"location":"algorithms/zero_crossing/#algorithm-description","title":"Algorithm Description","text":"<p>Zero crossing rate (ZCR) is a common feature in signal processing to detect signal changes and activity transitions. The algorithm:</p> <ol> <li>Computes differences between consecutive acceleration samples</li> <li>Identifies zero crossings (sign changes) exceeding a threshold</li> <li>Counts crossings within sliding windows</li> <li>Aggregates results over specified time periods</li> </ol> <p>Zero crossing rate increases with activity intensity, making it useful for activity classification.</p>"},{"location":"algorithms/zero_crossing/#parameters","title":"Parameters","text":""},{"location":"algorithms/zero_crossing/#zerocrossingsettings","title":"ZeroCrossingSettings","text":"<ul> <li>window_len (default: 1 second) - Processing window length for calculating zero crossing rate</li> <li>aggregation_window (default: 60 seconds) - Time window for data aggregation</li> <li>zero_crossing_thr (default: 0.05 g) - Threshold for detecting zero crossings</li> </ul>"},{"location":"algorithms/zero_crossing/#usage-example","title":"Usage Example","text":"<pre><code>from physiodsp.activity.zero_crossing import ZeroCrossing, ZeroCrossingSettings\nfrom physiodsp.sensors.imu.base import IMUData\nimport numpy as np\n\n# Create sample IMU data\ntimestamps = np.arange(0, 100, 0.01)  # 100 seconds at 100 Hz\nx = np.sin(np.linspace(0, 20*np.pi, len(timestamps))) * 0.5\ny = np.cos(np.linspace(0, 20*np.pi, len(timestamps))) * 0.5\nz = np.ones(len(timestamps))\n\nimu_data = IMUData(\n    timestamps=timestamps,\n    x=x,\n    y=y,\n    z=z,\n    fs=100  # 100 Hz sampling frequency\n)\n\n# Initialize Zero Crossing with custom settings\nsettings = ZeroCrossingSettings(\n    window_len=1,\n    aggregation_window=60,\n    zero_crossing_thr=0.05\n)\nzcr = ZeroCrossing(settings=settings)\n\n# Run algorithm\nresult = zcr.run(imu_data)\n\n# Get results\nprint(result.biomarker)  # DataFrame with zero crossing counts\n</code></pre>"},{"location":"algorithms/zero_crossing/#output","title":"Output","text":"<p>The algorithm returns a Pandas DataFrame with:</p> <ul> <li>timestamps: Unix timestamps of window centers</li> <li>x: Zero crossing rate for X-axis</li> <li>y: Zero crossing rate for Y-axis</li> <li>z: Zero crossing rate for Z-axis</li> </ul>"},{"location":"algorithms/zero_crossing/#applications","title":"Applications","text":"<ul> <li>Activity intensity estimation</li> <li>Movement pattern recognition</li> <li>Wake/sleep cycle detection</li> <li>Tremor and movement disorder assessment</li> </ul>"},{"location":"algorithms/zero_crossing/#references","title":"References","text":"<ul> <li>Zero crossing rate as a signal feature</li> <li>Accelerometer-based activity recognition</li> </ul>"},{"location":"coverage/","title":"Coverage Report","text":"<p>::: coverage</p> <p> </p>"}]}